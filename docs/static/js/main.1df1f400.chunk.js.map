{"version":3,"sources":["App.js","components/Header.js","serviceWorker.js","index.js","images/logo.svg"],"names":["videoEl","overlay","Component","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","selectedFaceDetector","FaceDetector","SSD_MOBILENETV1","TINY_FACE_DETECTOR","MTCNN","minConfidence","inputSize","scoreThreshold","minFaceSize","withFaceLandmarks","withBoxes","forwardTimes","time","fps","document","getElementById","initDevices","changeFaceDetector","navigator","mediaDevices","getUserMedia","video","stream","srcObject","detector","isFaceDetectionModelLoaded","getCurrentFaceDetectionNet","load","faceapi","faceLandmark68Net","faceRecognitionNet","paused","ended","setTimeout","_this2","onPlay","options","getFaceDetectorOptions","ts","Date","now","faceDetectionTask","result","updateTimeStats","drawFunction","drawLandmarks","bind","drawDetections","dimensions","canvas","results","resizedDetections","resizeCanvasAndResults","arguments","length","undefined","resizedResults","map","det","detection","faceLandmarks","landmarks","lineWidth","drawLines","color","e","_ref","HTMLVideoElement","width","height","res","forSize","timeInMs","setState","concat","slice","avgTimeInMs","reduce","total","t","Math","round","params","_this$state","ssdMobilenetv1","tinyFaceDetector","mtcnn","_this$state2","_this3","react_default","a","createElement","className","id","autoPlay","muted","type","checked","onChange","target","htmlFor","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.1df1f400.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.scss';\n\nimport Header from './components/Header';\n\nimport * as faceapi from 'face-api.js';\n\nlet videoEl, overlay;\n\nclass App extends Component {\n\n  constructor() {\n    super();\n    this.state = {\n      selectedFaceDetector: 'SSD_MOBILENETV1',\n      FaceDetector: {\n        SSD_MOBILENETV1: 'SSD_MOBILENETV1',\n        TINY_FACE_DETECTOR: 'TINY_FACE_DETECTOR',\n        MTCNN: 'MTCNN',\n      },\n      minConfidence: 0.5,\n      inputSize: 512,\n      scoreThreshold: 0.5,\n      minFaceSize: 20,\n      withFaceLandmarks: true,\n      withBoxes: true,\n      forwardTimes: [],\n      time: 0,\n      fps: 0,\n    }\n  }\n\n  componentDidMount() {\n    videoEl = document.getElementById('inputVideo');\n    overlay = document.getElementById('overlay');\n\n    this.initDevices();\n\n    // faceapi.nets.ssdMobilenetv1\n    // faceapi.nets.mtcnn\n    // faceapi.nets.tinyFaceDetector\n    // console.log(faceapi.nets);\n  }\n\n  async initDevices() {\n    // load face detection and face landmark models\n    await this.changeFaceDetector(this.state.FaceDetector.TINY_FACE_DETECTOR)\n\n    // try to access users webcam and stream the images\n    // to the video element\n    const stream = await navigator.mediaDevices.getUserMedia({ video: {} })\n    videoEl.srcObject = stream;\n  }\n\n  async changeFaceDetector(detector) {\n    if (!this.isFaceDetectionModelLoaded()) {\n      await this.getCurrentFaceDetectionNet().load('/weights');\n      await faceapi.nets.faceLandmark68Net.load('/weights');\n      await faceapi.nets.faceRecognitionNet.load('/weights');\n    }\n  }\n\n  async onPlay() {\n\n    if (videoEl.paused || videoEl.ended || !this.isFaceDetectionModelLoaded()) {\n      return setTimeout(() => this.onPlay());\n    }\n\n    const options = this.getFaceDetectorOptions();\n    const ts = Date.now();\n\n    const faceDetectionTask = faceapi.detectSingleFace(videoEl, options);\n\n    const result = this.state.withFaceLandmarks\n      ? await faceDetectionTask.withFaceLandmarks()\n      : await faceDetectionTask;\n\n    this.updateTimeStats(Date.now() - ts);\n\n    const drawFunction = this.state.withFaceLandmarks\n      ? this.drawLandmarks.bind(this)\n      : this.drawDetections.bind(this);\n\n    if (result) {\n      drawFunction(videoEl, overlay, [result], this.state.withBoxes);\n    }\n\n    setTimeout(() => this.onPlay());\n  }\n\n  drawDetections(dimensions, canvas, results) {\n    const resizedDetections = this.resizeCanvasAndResults(dimensions, canvas, results);\n    faceapi.drawDetection(canvas, resizedDetections);\n  }\n\n  drawLandmarks(dimensions, canvas, results, withBoxes = true) {\n    try {\n      const resizedResults = this.resizeCanvasAndResults(dimensions, canvas, results);\n\n      if (withBoxes) {\n        faceapi.drawDetection(canvas, resizedResults.map(det => det.detection))\n      }\n\n      const faceLandmarks = resizedResults.map(det => det.landmarks);\n      const drawLandmarksOptions = {\n        lineWidth: 2,\n        drawLines: true,\n        color: '#ff0',\n      }\n      faceapi.drawLandmarks(canvas, faceLandmarks, drawLandmarksOptions);\n\n    } catch (e) { /* console.log(e); */ };\n  }\n\n  resizeCanvasAndResults(dimensions, canvas, results) {\n    const { width, height } = dimensions instanceof HTMLVideoElement\n      ? faceapi.getMediaDimensions(dimensions)\n      : dimensions;\n    canvas.width = width;\n    canvas.height = height;\n\n    // resize detections (and landmarks) in case displayed image is smaller than\n    // original size\n    return results.map(res => res.forSize(width, height));\n  }\n\n  updateTimeStats(timeInMs) {\n    const { forwardTimes } = this.state;\n    this.setState({\n      forwardTimes: [timeInMs].concat(forwardTimes).slice(0, 30)\n    });\n    const avgTimeInMs = this.state.forwardTimes.reduce((total, t) => total + t) / this.state.forwardTimes.length;\n\n    this.setState({\n      time: Math.round(avgTimeInMs),\n      fps: faceapi.round(1000 / avgTimeInMs),\n    });\n  }\n\n  isFaceDetectionModelLoaded() {\n    return !!this.getCurrentFaceDetectionNet().params\n  }\n\n  getCurrentFaceDetectionNet() {\n    const { selectedFaceDetector, FaceDetector } = this.state;\n    switch (selectedFaceDetector) {\n      case FaceDetector.SSD_MOBILENETV1: return faceapi.nets.ssdMobilenetv1;\n      case FaceDetector.TINY_FACE_DETECTOR: return faceapi.nets.tinyFaceDetector;\n      case FaceDetector.MTCNN: return faceapi.nets.mtcnn;\n      default: return null;\n    }\n  }\n\n  getFaceDetectorOptions() {\n    const { selectedFaceDetector, FaceDetector, minConfidence, inputSize, scoreThreshold, minFaceSize } = this.state;\n    return selectedFaceDetector === FaceDetector.SSD_MOBILENETV1\n      ? new faceapi.SsdMobilenetv1Options({ minConfidence })\n      : (\n        selectedFaceDetector === FaceDetector.TINY_FACE_DETECTOR\n          ? new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold })\n          : new faceapi.MtcnnOptions({ minFaceSize })\n      )\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"face\">\n          <video onPlay={this.onPlay.bind(this)} id=\"inputVideo\" autoPlay muted></video>\n          <canvas id=\"overlay\" />\n          <div className=\"state\">\n            <span>Time: {this.state.time} ms</span>\n            <span>Estimated Fps: {this.state.fps}</span>\n          </div>\n          <div className=\"control\">\n            <input\n              id=\"lbmarks\"\n              type=\"checkbox\"\n              checked={this.state.withFaceLandmarks}\n              onChange={(e) => { this.setState({ withFaceLandmarks: e.target.checked }) }}\n            /><label htmlFor=\"lbmarks\">臉部輪廓</label>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React, { Component } from 'react';\nimport logo from '../images/logo.svg';\nimport './Header.scss';\n\nclass Header extends Component {\n  render() {\n    return (\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n          </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n          </a>\n      </header>\n    );\n  }\n}\n\nexport default Header;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}